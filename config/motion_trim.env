# ==============================================================================
# Motion Vector DVR Trimmer - Configuration File
# ==============================================================================
#
# This file controls how the motion detection algorithm works. Adjusting these
# values will change sensitivity, performance, and output quality.
#
# HOW IT WORKS:
# 1. The scanner extracts motion vectors (MVs) from H.264/HEVC video frames
# 2. Each frame's MVs are placed on a grid of blocks
# 3. Blocks with sufficient movement are marked as "active"
# 4. Adjacent active blocks form "clusters"
# 5. Frames with enough clusters are considered to have motion
# 6. Gaps between motion frames are cut from the final output
#
# ==============================================================================

# --- MOTION VECTOR SENSITIVITY ---
# ==============================================================================

# MV_THRESHOLD_SQ (default: 1.0)
# -----------------------------------------------------------------------------
# Squared magnitude threshold for counting a motion vector as "significant".
# Motion vectors represent pixel displacement between frames (dx, dy).
# We compare (dx*dx + dy*dy) against this threshold.
#
# Lower values = MORE SENSITIVE (detects smaller movements)
# Higher values = LESS SENSITIVE (ignores small movements)
#
# Examples:
#   1.0  = Detects movement >= 1 pixel   (VERY sensitive, may catch noise)
#   4.0  = Detects movement >= 2 pixels  (Good balance)
#   16.0 = Detects movement >= 4 pixels  (Only significant motion)
#   64.0 = Detects movement >= 8 pixels  (Major movements only)
#
MV_THRESHOLD_SQ=4.0

# ==============================================================================
# --- GRID CONFIGURATION ---
# ==============================================================================

# BLOCK_SIZE (default: 16)
# -----------------------------------------------------------------------------
# Size of each grid cell in pixels. The video frame is divided into a grid
# of BLOCK_SIZE x BLOCK_SIZE pixel blocks for motion analysis.
# 16 matches H.264/HEVC macroblock size - changing this is not recommended.
#
BLOCK_SIZE=16

# BLOCK_SHIFT (default: 4)
# -----------------------------------------------------------------------------
# Bit-shift value for fast division by BLOCK_SIZE (16 = 2^4 = shift by 4).
# Must match BLOCK_SIZE: BLOCK_SIZE = 2^BLOCK_SHIFT
# Examples: 16 -> 4, 8 -> 3, 32 -> 5
#
BLOCK_SHIFT=4

# ==============================================================================
# --- DETECTION THRESHOLDS ---
# ==============================================================================

# VECTORS_NEEDED (default: 1)
# -----------------------------------------------------------------------------
# Minimum number of significant motion vectors required within a single
# grid block to mark that block as "active".
#
# Lower values = MORE SENSITIVE (1 = any movement activates a block)
# Higher values = LESS SENSITIVE (requires multiple vectors per block)
#
# Examples:
#   1 = Very sensitive - one moving thing in a block triggers it
#   2 = Moderate - requires a couple of vectors per block
#   4 = Conservative - block needs substantial internal motion
#
VECTORS_NEEDED=4

# CLUSTERS_NEEDED (default: 1)
# -----------------------------------------------------------------------------
# Minimum number of "clusters" (groups of adjacent active blocks) required
# to declare that a frame contains motion.
#
# A cluster = an active block that has at least one adjacent active neighbor.
# This helps filter out random noise (isolated single blocks).
#
# Lower values = MORE SENSITIVE (1 = any cluster triggers)
# Higher values = LESS SENSITIVE (requires multiple motion regions)
#
# Examples:
#   1 = Detect any coherent motion region
#   2 = Require at least 2 separate motion areas
#   4 = Only trigger when significant activity is present
#
CLUSTERS_NEEDED=2

# ==============================================================================
# --- FRAME MASKING ---
# ==============================================================================

# VERTICAL_MASK (default: 0.0)
# -----------------------------------------------------------------------------
# Fraction of the frame height to IGNORE at top and bottom edges.
# Useful for eliminating false positives from timestamps, watermarks,
# or motion in fixed UI elements.
#
# Range: 0.0 (no masking) to 0.5 (analyze only middle horizontal strip)
#
# Examples:
#   0.0   = Analyze entire frame (no masking)
#   0.05  = Ignore top 5% and bottom 5% of frame
#   0.10  = Ignore top 10% and bottom 10% (good for timestamped footage)
#   0.20  = Analyze only middle 60% of frame height
#
VERTICAL_MASK=0.05

# ==============================================================================
# --- PERFORMANCE ---
# ==============================================================================

# MAX_THREADS (default: 6)
# -----------------------------------------------------------------------------
# Maximum number of parallel worker threads for scanning.
# Each thread processes a different time segment of the video.
#
# Recommendation: Set to (CPU cores / 2) to leave room for decoder threads.
# Too many threads may cause cache thrashing and slower performance.
#
# Examples:
#   4  = Good for 8-core systems
#   6  = Good for 12-core systems
#   8  = Good for 16+ core systems
#
MAX_THREADS=5

# ==============================================================================
# --- SEGMENT TIMING ---
# ==============================================================================

# MAX_GAP_SEC (default: 10.0)
# -----------------------------------------------------------------------------
# Maximum gap (in seconds) between motion events before splitting segments.
# If no motion is detected for longer than this, the gap is cut.
#
# Lower values = MORE aggressive cutting (cuts shorter pauses)
# Higher values = LESS aggressive cutting (tolerates longer pauses)
#
# Examples:
#   5.0   = Cut if no motion for 5 seconds (aggressive)
#   10.0  = Cut if no motion for 10 seconds (balanced)
#   30.0  = Only cut long periods of inactivity
#   60.0  = Very conservative, only cut 1+ minute gaps
#
MAX_GAP_SEC=5.0

# PADDING_SEC (default: 2.0)
# -----------------------------------------------------------------------------
# Seconds of padding to add BEFORE and AFTER each motion segment.
# Prevents cutting off action that's just starting or ending.
#
# Lower values = Tighter cuts (more savings, but may clip edges)
# Higher values = Safer cuts (less savings, but preserves context)
#
# Examples:
#   0.5  = Very tight cuts, minimal padding
#   1.0  = Balanced padding
#   2.0  = Safe padding, good for security footage
#   5.0  = Very generous padding
#
PADDING_SEC=0.5

# ==============================================================================
# --- PERFORMANCE ---
# ==============================================================================

# CHUNK_DURATION_SEC (default: 30.0)
# -----------------------------------------------------------------------------
# Duration of each work chunk for parallel processing (in seconds).
# The video is divided into chunks of this size, and worker threads
# dynamically steal chunks from a shared queue.
#
# Smaller chunks = Better load balancing (threads stay busy)
# Larger chunks = Less overhead (fewer seek operations)
#
# Examples:
#   10.0  = Small chunks, excellent load balancing, more overhead
#   30.0  = Balanced (default, good for most footage)
#   60.0  = Large chunks, less overhead, may have idle threads
#
CHUNK_DURATION_SEC=60.0

# TARGET_FPS (default: 0.0 = analyze all frames)
# -----------------------------------------------------------------------------
# Target frames-per-second for motion analysis.
# This enables frame skipping to dramatically reduce processing time.
#
# How it works:
# - If video is 25fps and TARGET_FPS=5, only every 5th frame is analyzed
# - Motion detection is still effective because motion persists across frames
# - Great speedup with minimal loss of accuracy
#
# 0.0 (default) = Analyze all frames (most accurate, slowest)
# Lower values = Faster processing but may miss very brief motion
#
# Examples:
#   0.0   = All frames (no skipping)
#   5.0   = 5 fps - 5x speedup, good for security footage
#   10.0  = 10 fps - 2.5x speedup, balanced
#   25.0  = All frames for 25fps video (no skipping)
#
# RECOMMENDED: Set to 10.0 for security/DVR footage
#
TARGET_FPS=10.0

# MIN_SAVINGS_PCT (default: 5.0)
# -----------------------------------------------------------------------------
# Minimum percentage of video that must be cut before outputting a new file.
# If the motion removal results in less than this percentage of savings,
# the cutting process is skipped, and the ORIGINAL file is copied to the output.
# This ensures that files with significant motion (or little savings) are preserved
# entirely, which is critical if the input directory is regulated/deleted.
#
# This prevents creating nearly-identical output files when there's little
# to cut, saving disk space and processing time.
#
# Examples:
#   1.0   = Cut if at least 1% can be removed (aggressive)
#   5.0   = Cut if at least 5% can be removed (default, balanced)
#   10.0  = Cut if at least 10% can be removed (conservative)
#   0.0   = Always cut, even if no savings
#
MIN_SAVINGS_PCT=5.0

# ==============================================================================
# --- PARALLEL VIDEO STREAMS ---
# ==============================================================================

# PARALLEL_STREAMS (default: 0 = auto-detect)
# -----------------------------------------------------------------------------
# Number of videos to process concurrently in batch mode.
# Each stream is a separate worker thread that processes videos from a queue.
#
# 0 (default) = Auto-detect based on available CPUs (uses all CPUs)
#
# How it works:
# - In batch mode, multiple videos are processed simultaneously
# - Each stream gets its own CPU set based on THREADS_PER_STREAM
# - All available CPUs are used (no reservation)
# - Docker-compose CPU limits are respected automatically
#
# Examples:
#   0   = Auto-detect (uses all CPUs)
#   1   = Single video at a time (sequential)
#   2   = Two videos in parallel
#   4   = Four videos in parallel
#
PARALLEL_STREAMS=2

# THREADS_PER_STREAM (default: 0 = auto-calculate)
# -----------------------------------------------------------------------------
# This value controls THREE things per stream:
#   1. Number of internal chunk scanning threads
#   2. Number of CPUs allocated to the stream (via thread pinning)
#   3. Number of CPUs for FFmpeg process (via taskset)
#
# 0 (default) = Auto-calculate as (available_cpus / parallel_streams)
# N           = Use exactly N threads and N CPUs per stream
#
# CPU ALLOCATION EXAMPLE (8 CPUs, PARALLEL_STREAMS=4, THREADS_PER_STREAM=2):
#
#   Stream 0 -> CPUs [0,1]  (2 scanning threads + FFmpeg pinned to 0,1)
#   Stream 1 -> CPUs [2,3]  (2 scanning threads + FFmpeg pinned to 2,3)
#   Stream 2 -> CPUs [4,5]  (2 scanning threads + FFmpeg pinned to 4,5)
#   Stream 3 -> CPUs [6,7]  (2 scanning threads + FFmpeg pinned to 6,7)
#
# IMPORTANT:
#   Total CPUs used = PARALLEL_STREAMS × THREADS_PER_STREAM
#   This should NOT exceed available CPUs for optimal performance.
#
# RECOMMENDED CONFIGURATIONS:
#   8 CPUs: PARALLEL_STREAMS=4, THREADS_PER_STREAM=2 (4×2 = 8)
#   8 CPUs: PARALLEL_STREAMS=2, THREADS_PER_STREAM=4 (2×4 = 8)
#  16 CPUs: PARALLEL_STREAMS=4, THREADS_PER_STREAM=4 (4×4 = 16)
#
THREADS_PER_STREAM=1

# WATCH_MODE (default: 0 = disabled)
# -----------------------------------------------------------------------------
# Enable continuous monitoring of the input directory for new files.
#
# 0 (default) = Process existing files and exit (Batch Mode)
# 1           = Monitor directory and process new files as they arrive (Watch Mode)
#
# Note: In Watch Mode, the application will not exit. It polls the directory
#       every few seconds for new content.
#
WATCH_MODE=1

# ==============================================================================
# END OF CONFIGURATION
# ==============================================================================